/*
 * Copyright 2013 LinkedIn Corp. All rights reserved
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
package com.linkedin.databus.client.pub.mbean;


import java.io.IOException;
import java.io.OutputStream;
import java.util.Hashtable;
import java.util.List;
import java.util.concurrent.locks.Lock;

import javax.management.MBeanServer;
import javax.management.MalformedObjectNameException;
import javax.management.ObjectName;

import org.apache.avro.io.JsonEncoder;
import org.apache.avro.specific.SpecificDatumWriter;

// auto-generated by Avro from UnifiedClientStatsEvent.*.avsc:
import com.linkedin.databus.client.pub.monitoring.events.UnifiedClientStatsEvent;
import com.linkedin.databus.core.DbusClientMode;
import com.linkedin.databus.core.DbusConstants;
import com.linkedin.databus.core.DbusEvent;
import com.linkedin.databus.core.monitoring.mbean.AbstractMonitoringMBean;
import com.linkedin.databus.core.monitoring.mbean.StatsCollectorMergeable;

/**
 * Joint relay/bootstrap client-library metrics for Databus v2 and v3 consumers.  At the lowest
 * level, these stats may represent a single table (in a v2 multi-tenant setup) or a single
 * partition for a single table (in a client load-balancing [CLB] setup); in the latter case,
 * they may not even be exposed.  The same class is also used to aggregate stats over multiple
 * partitions and/or tables.  Thus in the CLB case, for example, the lowest level is one partition
 * of a table; the second level is aggregated across all partitions for a single table; and the
 * third level is aggregated across all tables [for a single DB or for all subscriptions? TODO/FIXME].
 *
 * This class is intended to supersede ConsumerCallbackStats for consumers.
 */
public class UnifiedClientStats extends AbstractMonitoringMBean<UnifiedClientStatsEvent>
                                implements UnifiedClientStatsMBean,
                                           StatsCollectorMergeable<UnifiedClientStats>
{
  // default threshold for lack of data events to be considered "idle":
  public static final int DEFAULT_DEADNESS_THRESHOLD_MS = 300000;

  private final String _name;
  private final String _dimension;  // used in MBean/JMX naming to distinguish similar collectors; see mbeanProps below
  private final MBeanServer _mbeanServer;

  private long _deadnessThresholdMs;

  // TODO //private boolean _isBootstrapping = false;

  // used only by tests:
  public UnifiedClientStats(int ownerId, String name, String dimension)
  {
    this(ownerId, name, dimension, true, false, DEFAULT_DEADNESS_THRESHOLD_MS, null, null);
  }

  public UnifiedClientStats(int ownerId, String name, String dimension, boolean enabled,
                            boolean threadSafe, long deadnessThresholdMs, UnifiedClientStatsEvent initData)
  {
    this(ownerId, name, dimension, enabled, threadSafe, deadnessThresholdMs, initData, null);
  }

  public UnifiedClientStats(int ownerId, String name, String dimension, boolean enabled,
                            boolean threadSafe, long deadnessThresholdMs, UnifiedClientStatsEvent initData,
                            MBeanServer server)
  {
    super(enabled, threadSafe, initData);
    _event.ownerId = ownerId;
    _name = name;
    _dimension = dimension;
    _deadnessThresholdMs = deadnessThresholdMs;
    _mbeanServer = server;
    resetData();
    registerAsMbean();
  }

  public void setBootstrappingState(boolean isBootstrapping)
  {
    if (!_enabled.get()) return;
    Lock writeLock = acquireWriteLock();
    try
    {
      // TODO //_isBootstrapping = isBootstrapping;
      _event.curBootstrappingPartitions = isBootstrapping ? 1 : 0;
    }
    finally
    {
      releaseLock(writeLock);
    }
  }

  public void setHeartbeatTimestamp(long heartbeatTimestamp)
  {
    if (!_enabled.get()) return;
    Lock writeLock = acquireWriteLock();
    try
    {
      _event.timestampOfLastHeartbeat = heartbeatTimestamp;
    }
    finally
    {
      releaseLock(writeLock);
    }
  }

  // used only for tests (=> no need for corresponding getter)
  public void setDeadnessThresholdMs(long deadnessThresholdMs)
  {
    _deadnessThresholdMs = deadnessThresholdMs;
  }

  public String getDimension()
  {
    return _dimension;
  }

  public String getName()
  {
    return _name;
  }

  public void registerAsMbean()
  {
    super.registerAsMbean(_mbeanServer);
  }

  public void unregisterAsMbean()
  {
    super.unregisterMbean(_mbeanServer);
  }

  @Override
  public JsonEncoder createJsonEncoder(OutputStream out) throws IOException
  {
    return new JsonEncoder(_event.getSchema(), out);
  }

  @Override
  public ObjectName generateObjectName() throws MalformedObjectNameException
  {
    Hashtable<String, String> mbeanProps = generateBaseMBeanProps();
    mbeanProps.put("ownerId", Integer.toString(_event.ownerId));
    mbeanProps.put("dimension", _dimension);
    return new ObjectName(AbstractMonitoringMBean.JMX_DOMAIN, mbeanProps);
  }

  // called by ctor above (no lock required) and by reset() in superclass (which acquires write lock)
  @Override
  protected void resetData()
  {
    long now = System.currentTimeMillis();

    _event.timestampLastResetMs = now;
    _event.aggregated = false;
    _event.curBootstrappingPartitions = 0;
    _event.curDeadConnections = 0;
    _event.numConsumerErrors = 0;
    _event.numDataEvents = 0;
    _event.numCallbacksProcessed = 0;
    _event.totalTimeLagCallbacksProcessed = 0;
    _event.timestampOfLastHeartbeat = now;
    _event.sourceTimestampOfLastEventReceived = 0;  // timestamp values are always stored in ms
    _event.timestampLastDataEventWasReceived = 0;   // ditto
  }

  // called only by getStatistics() in superclass (which acquires read lock)
  @Override
  protected void cloneData(UnifiedClientStatsEvent event)
  {
    // ConsumerCallbackStats doesn't do this... // event.timestampLastResetMs               = _event.timestampLastResetMs;
    event.aggregated                         = _event.aggregated;
    event.curBootstrappingPartitions         = _event.curBootstrappingPartitions;
    event.curDeadConnections                 = _event.curDeadConnections;
    event.numConsumerErrors                  = _event.numConsumerErrors;
    event.numDataEvents                      = _event.numDataEvents;
    event.numCallbacksProcessed              = _event.numCallbacksProcessed;
    event.totalTimeLagCallbacksProcessed     = _event.totalTimeLagCallbacksProcessed;
    event.timestampOfLastHeartbeat           = _event.timestampOfLastHeartbeat;
    event.sourceTimestampOfLastEventReceived = _event.sourceTimestampOfLastEventReceived;
    event.timestampLastDataEventWasReceived  = _event.timestampLastDataEventWasReceived;
  }

  @Override
  protected UnifiedClientStatsEvent newDataEvent()
  {
    return new UnifiedClientStatsEvent();
  }

  @Override
  protected SpecificDatumWriter<UnifiedClientStatsEvent> getAvroWriter()
  {
    return new SpecificDatumWriter<UnifiedClientStatsEvent>(UnifiedClientStatsEvent.class);
  }

  // called by superclass's (AbstractMonitoringMBean's) mergeStats() and by
  // StatsCollectors.mergeStatsCollectors() -> resetAndMerge() -> merge(); callers
  // handle locking
  @Override
  protected void doMergeStats(Object eventData)
  {
    if (!(eventData instanceof UnifiedClientStatsEvent))
    {
      if (!(eventData instanceof UnifiedClientStats))
      {
        LOG.warn("Attempt to merge unknown event class: " + eventData.getClass().getName());
        return;
      }
      eventData = ((UnifiedClientStats)eventData)._event;
    }
    UnifiedClientStatsEvent e = (UnifiedClientStatsEvent)eventData;

    _event.aggregated = true;

    // standalone metrics; aggregation = simple sum:
    _event.curBootstrappingPartitions  += e.curBootstrappingPartitions;
    _event.numConsumerErrors           += e.numConsumerErrors;
    _event.numDataEvents               += e.numDataEvents;

    // special-case, half-standalone/half-derived metric:  aggregation = slightly complicated...
    if (e.aggregated)
    {
      // we're the third (or higher) level up, so it's safe to trust the lower level's count; just add it in:
      _event.curDeadConnections += e.curDeadConnections;
    }
    else if (System.currentTimeMillis() - e.timestampOfLastHeartbeat > _deadnessThresholdMs)
    {
      // we're the second level (first level of aggregation), so we need to check the first level's timestamp
      // to see if its connection is dead
      ++_event.curDeadConnections;
    }

    // support metrics for timeLagConsumerCallbacksMs (simple/brain-dead averaging version); aggregation = simple sum,
    // but actual metric is result of division:
    _event.totalTimeLagCallbacksProcessed += e.totalTimeLagCallbacksProcessed;
    _event.numCallbacksProcessed          += e.numCallbacksProcessed;

    // support metrics for timeLagLastReceivedToNowMs; since want worst case across aggregated time lags
    // (i.e., maximum interval), want _minimum_ (oldest) timestamp:
    _event.timestampLastDataEventWasReceived = (_event.timestampLastDataEventWasReceived != 0) ?
        Math.min(_event.timestampLastDataEventWasReceived, e.timestampLastDataEventWasReceived) :
        e.timestampLastDataEventWasReceived;

    // current (interim) version of getTimeLagSourceToReceiptMs() uses sourceTimestampOfLastEventReceived with
    // timestampLastDataEventWasReceived, so the two must be consistent
    // [TEMPORARY ISSUE:  final version will involve histogram => different consistency issues]
    if (_event.timestampLastDataEventWasReceived == e.timestampLastDataEventWasReceived)
    {
      _event.sourceTimestampOfLastEventReceived = e.sourceTimestampOfLastEventReceived;
    } // else already consistent with _event.timestampLastDataEventWasReceived

    // TODO:  set up percentiles (50/90/95/99) for timeLagSourceToReceiptMs and
    //        sliding-window max for timeLagConsumerCallbacksMs
    //        - see http://metrics.codahale.com/manual/core/ [recommendation by Kafka/Voldemort folks]

  }

  @Override
  public void merge(UnifiedClientStats obj)
  {
    if (!_enabled.get()) return;
    Lock writeLock = acquireWriteLock();
    try
    {
      doMergeStats(obj);
    }
    finally
    {
      releaseLock(writeLock);
    }
  }

  // called by StatsCollectors.mergeStatsCollectors()
  @Override
  public void resetAndMerge(List<UnifiedClientStats> objList)
  {
    Lock writeLock = acquireWriteLock();
    try
    {
      reset();
      for (UnifiedClientStats t: objList)
      {
        merge(t);
      }
    }
    finally
    {
      releaseLock(writeLock);
    }
  }



  // We use "cur" (a.k.a. "current") instead of "num" to prevent MBeanSensorHelper from treating this
  // metric as an RRD counter.  (We want gauge instead.)
  @Override
  public int getCurBootstrappingPartitions()
  {
    int result = 0;
    Lock readLock = acquireReadLock();
    try
    {
      result = _event.curBootstrappingPartitions;
    }
    finally
    {
      releaseLock(readLock);
    }
    return result;
  }

  // We use "cur" (a.k.a. "current") instead of "num" to prevent MBeanSensorHelper from treating this
  // metric as an RRD counter.  (We want gauge instead.)
  @Override
  public int getCurDeadConnections()
  {
    int result = 0;
    Lock readLock = acquireReadLock();
    try
    {
      // For the lowest-level (non-aggregated) stats, which we detect via register*() calls, this getter is the
      // most reasonable place to check whether we're dead.  But it may never be called (or only rarely), so we
      // can't rely on its calculation of curDeadConnections to compute the aggregated versions.  (And we
      // certainly can't depend on further register* calls if we're dead.)  Ergo, for aggregated versions, do a
      // separate calculation in doMergeStats().
      if (!_event.aggregated)
      {
        long timeIntervalSinceHeartbeatMs = System.currentTimeMillis() - _event.timestampOfLastHeartbeat;
        _event.curDeadConnections = (timeIntervalSinceHeartbeatMs > _deadnessThresholdMs) ? 1 : 0;
      }
      result = _event.curDeadConnections;
    }
    finally
    {
      releaseLock(readLock);
    }
    return result;
  }

  @Override
  public long getNumConsumerErrors()
  {
    long result = 0;
    Lock readLock = acquireReadLock();
    try
    {
      result = _event.numConsumerErrors;
    }
    finally
    {
      releaseLock(readLock);
    }
    return result;
  }

  @Override
  public long getNumDataEvents()
  {
    long result = 0;
    Lock readLock = acquireReadLock();
    try
    {
      result = _event.numDataEvents;
    }
    finally
    {
      releaseLock(readLock);
    }
    return result;
  }

// [decided with Sunil that it's better not to expose a temporary metric in the first place; deprecation is a pain with this stuff]
//// timeLagSourceToReceiptMs
//// TODO (DDSDBUS-3470):  WANT PERCENTILES (50/90/95/99)
//@Override
//public long getTimeLagSourceToReceiptMs()  // currently just most recent event's lag; want median/90th/95th/99th percentiles, though
//{
//  long result = 0;
//  Lock readLock = acquireReadLock();
//  try
//  {
//    // THIS IS A TEMPORARY STANDIN:  just most recent value, or -1 if no data events received:  FIXME
//    // FIXME 2:  also set to -1 if in bootstrap mode, i.e., if (_isBootstrapping), and aggregate -1 values appropriately
//    result = (_event.timestampLastDataEventWasReceived > 0) ?
//             _event.timestampLastDataEventWasReceived - _event.sourceTimestampOfLastEventReceived :
//             AbstractMonitoringMBean.DEFAULT_MIN_LONG_VALUE;
//  }
//  finally
//  {
//    releaseLock(readLock);
//  }
//  return result;
//}

  // timeLagLastReceivedToNowMs
  // DONE:  want max time lag over whatever is being aggregated, i.e., track the _minimum_ (oldest) timestamp
  @Override
  public long getTimeLagLastReceivedToNowMs()
  {
    long result = 0;
    Lock readLock = acquireReadLock();
    try
    {
      result = (_event.timestampLastDataEventWasReceived != 0) ?
          System.currentTimeMillis() - _event.timestampLastDataEventWasReceived : -1;
    }
    finally
    {
      releaseLock(readLock);
    }
    return result;
  }

// [decided with Sunil that it's better not to expose a temporary metric in the first place; deprecation is a pain with this stuff]
//// timeLagConsumerCallbacksMs
//// TODO (DDSDBUS-3470):  WANT MAX (WORST-CASE VALUE) WITHIN LIMITED SLIDING WINDOW => require time-interval buckets, sliding window
//@Override
//public long getTimeLagConsumerCallbacksMs()  // intentionally not using double; integer milliseconds is fine
//{
//  long result = 0;
//  Lock readLock = acquireReadLock();
//  try
//  {
//    // THIS IS A TEMPORARY STANDIN:  simple (brain-dead) average over all time (i.e., since service last restarted):  FIXME
//    result = (_event.numCallbacksProcessed != 0) ?
//             _event.totalTimeLagCallbacksProcessed / _event.numCallbacksProcessed : 0;
//  }
//  finally
//  {
//    releaseLock(readLock);
//  }
//  return result;
//}

  @Override
  public long getTimeSinceLastResetMs()
  {
    long result = 0;
    Lock readLock = acquireReadLock();
    try
    {
      result = System.currentTimeMillis() - _event.timestampLastResetMs;
    }
    finally
    {
      releaseLock(readLock);
    }
    return result;
  }

  @Override
  public long getTimestampLastResetMs()
  {
    long result = 0;
    Lock readLock = acquireReadLock();
    try
    {
      result = _event.timestampLastResetMs;
    }
    finally
    {
      releaseLock(readLock);
    }
    return result;
  }

  //----------------------------- "EVENTS RECEIVED" CALLS -----------------------------
  // ("received" by client lib from relay or bootstrap but not yet passed to consumer)

  // called only by MultiConsumerCallback => only for lowest-level (non-aggregated) stats
  public void registerDataEventReceived(DbusEvent e)
  {
    if (!_enabled.get()) return;
    Lock writeLock = acquireWriteLock();
    try
    {
      ++_event.numDataEvents;
      _event.timestampLastDataEventWasReceived = System.currentTimeMillis();
      _event.sourceTimestampOfLastEventReceived = e.timestampInNanos() / DbusConstants.NUM_NSECS_IN_MSEC;
    }
    finally
    {
      releaseLock(writeLock);
    }
  }

  //----------------------------- "EVENTS PROCESSED" CALLS -----------------------------
  // ("processed" by consumer, i.e., output side of client lib)

  // formerly registerEventsProcessed()
  public void registerCallbacksProcessed(long timeElapsed)  // size argument never used (always 1) => OMIT
  {
    if (!_enabled.get()) return;
    Lock writeLock = acquireWriteLock();
    try
    {
      _event.totalTimeLagCallbacksProcessed += timeElapsed;
      ++_event.numCallbacksProcessed;  // used only with totalTimeLagCallbacksProcessed to calc avg latency of callbacks:  DO WE NEED IN FINAL PERCENTILE/HISTOGRAM VERSION?  FIXME
    }
    finally
    {
      releaseLock(writeLock);
    }
  }

  //----------------------------- "ERRORS PROCESSED" CALLS -----------------------------

  // was registerErrorEventsProcessed()
  public void registerCallbackError()
  {
    if (!_enabled.get()) return;
    Lock writeLock = acquireWriteLock();
    try
    {
      ++_event.numConsumerErrors;
    }
    finally
    {
      releaseLock(writeLock);
    }
  }

}
